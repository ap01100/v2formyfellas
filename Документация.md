# **Документация для разработчика по модулю тестирования прокси-конфигураций (двухфайловая структура)**

Данный документ предназначен для программистов, занимающихся разработкой и сопровождением модуля тестирования прокси-конфигураций. Он описывает новую двухфайловую структуру проекта, где первый файл отвечает за быстрый URL-тест, а второй — за более глубокие проверки оставшихся конфигураций.

## **1\. Общая структура проекта**

Проект будет разделен на два основных Python-файла:

1. **url\_test.py:** Содержит код для выполнения быстрого URL-теста прокси-конфигураций. Этот файл отфильтрует большинство нерабочих конфигураций.  
2. **advanced\_test.py:** Содержит код для выполнения более тщательных тестов (TCP пинг, задержка TCP, определение IN и OUT IP) над конфигурациями, успешно прошедшими URL-тест.

## **2\. url\_test.py \- Модуль URL-тестирования**

### **2.1. Назначение**

Этот модуль отвечает за первоначальную фильтрацию списка прокси-конфигураций путем проверки их способности успешно устанавливать соединение с заданным URL-адресом через sing-box.

### **2.2. Содержимое модуля**

Модуль url\_test.py будет содержать следующий код (практически идентичный текущему коду):

* Импорты необходимых библиотек.  
* Константы (DEFAULT\_TEST\_URL, DEFAULT\_TIMEOUT, DEFAULT\_WORKERS, SINGBOX\_EXECUTABLE).  
* Вспомогательные функции (find\_free\_port, cleanup\_process, cleanup\_file).  
* Функции парсинга конфигураций (parse\_ss\_config, parse\_trojan\_config, parse\_vmess\_config, parse\_vless\_config).  
* Функция convert\_to\_singbox\_config.  
* Основная функция тестирования URL (perform\_url\_test).  
* Основная функция main(), которая будет:  
  * Парсить аргументы командной строки (путь к файлу с конфигурациями, URL для теста, таймаут, путь к sing-box, количество рабочих потоков, флаг verbose).  
  * Читать список конфигураций из входного файла.  
  * Запускать параллельное тестирование URL с использованием concurrent.futures.ThreadPoolExecutor и функции perform\_url\_test.  
  * Собирать список рабочих конфигураций (те, которые успешно прошли URL-тест).  
  * **Вместо записи рабочих конфигураций в выходной файл, этот файл должен передать список рабочих конфигураций модулю advanced\_test.py.**

### **2.3. Изменения в url\_test.py для связи с advanced\_test.py**

Для того чтобы url\_test.py запускал advanced\_test.py и передавал ему список успешно протестированных конфигураций, необходимо внести следующие изменения в функцию main():

1. **Импорт модуля subprocess:** Добавьте import subprocess в начало файла.  
2. **Определение пути к advanced\_test.py:** Определите переменную, содержащую путь к файлу advanced\_test.py. Это может быть константа или аргумент командной строки.  
3. **Передача рабочих конфигураций:** После завершения URL-тестирования и получения списка working\_configs, необходимо передать этот список в advanced\_test.py. Существует несколько способов это сделать:  
   * **Сохранение во временный файл:** url\_test.py может сохранить список рабочих конфигураций в JSON-файл или текстовый файл (по одной конфигурации на строку) во временной директории. Затем advanced\_test.py будет читать этот файл.  
   * **Передача через аргументы командной строки:** Если список не слишком длинный, можно передать его как серию аргументов командной строки при запуске advanced\_test.py. Однако этот метод может быть ограничен длиной командной строки.  
   * **Использование pickle или другого механизма сериализации:** Можно использовать pickle для сериализации списка Python в файл, который затем может быть десериализован в advanced\_test.py.

**Рекомендуемый подход: Сохранение во временный файл.** Этот метод является достаточно надежным и позволяет передавать большие объемы данных.

4. **Запуск advanced\_test.py:** Используйте subprocess.run() для запуска скрипта advanced\_test.py. Передайте путь к временному файлу с рабочими конфигурациями в качестве аргумента командной строки для advanced\_test.py.  
   Пример кода (внутри main() после получения working\_configs):  
   Python  
   import tempfile  
   import json  
   import subprocess  
   import sys

   \# Определите путь к advanced\_test.py  
   ADVANCED\_TEST\_SCRIPT \= "advanced\_test.py"

   if working\_configs:  
       \# Создаем временный файл для передачи рабочих конфигураций  
       with tempfile.NamedTemporaryFile(mode="w", suffix=".json", delete=False) as tmp\_file:  
           json.dump(working\_configs, tmp\_file)  
           temp\_file\_path \= tmp\_file.name

       logging.info(f"Передача {len(working\_configs)} рабочих конфигураций в {ADVANCED\_TEST\_SCRIPT}...")

       \# Формируем команду для запуска advanced\_test.py  
       cmd \= \# Передаем путь к sing-box

       if args.verbose:  
           cmd.append("--verbose")

       \# Запускаем advanced\_test.py  
       try:  
           result \= subprocess.run(cmd, check=True, capture\_output=True, text=True)  
           logging.info(f"{ADVANCED\_TEST\_SCRIPT} завершен. Вывод:\\n{result.stdout}")  
           if result.stderr:  
               logging.error(f"{ADVANCED\_TEST\_SCRIPT} вывел ошибки:\\n{result.stderr}")  
       except subprocess.CalledProcessError as e:  
           logging.error(f"Ошибка при запуске {ADVANCED\_TEST\_SCRIPT}: {e}")  
           logging.error(f"Вывод ошибки:\\n{e.stderr}")  
       except FileNotFoundError:  
           logging.error(f"Скрипт {ADVANCED\_TEST\_SCRIPT} не найден.")  
       finally:  
           \# Очищаем временный файл  
           import os  
           os.remove(temp\_file\_path)  
           logging.debug(f"Временный файл {temp\_file\_path} удален.")  
   else:  
       logging.info("После URL-теста не осталось рабочих конфигураций. Запуск advanced\_test.py пропущен.")

5. **Удаление записи в выходной файл:** Удалите из url\_test.py код, который записывает рабочие конфигурации в файл, так как эта задача теперь будет выполняться (возможно) в advanced\_test.py.

## **3\. advanced\_test.py \- Модуль углубленного тестирования**

### **3.1. Назначение**

Этот модуль принимает список прокси-конфигураций, успешно прошедших URL-тест, и выполняет над ними более глубокие проверки, включая TCP пинг, измерение задержки TCP и определение входящего и исходящего IP-адресов.

### **3.2. Содержимое модуля**

Модуль advanced\_test.py будет содержать следующий код:

* Импорты необходимых библиотек (time, socket, subprocess, json, argparse, logging, requests).  
* Константы (возможно, специфичные для этого модуля).  
* Вспомогательные функции (find\_free\_port, cleanup\_process, cleanup\_file \- можно скопировать из url\_test.py или создать общий модуль).  
* Функция tcp\_ping\_test(config\_str: str, target\_host: str, target\_port: int, singbox\_path: str, timeout: float) \-\> Tuple\[bool, Optional\[float\], Optional\[str\]\] (как описано в предыдущей документации).  
* Функция tcp\_latency\_test(config\_str: str, target\_host: str, target\_port: int, singbox\_path: str, timeout: float) \-\> Tuple\[bool, Optional\[float\], Optional\[str\]\] (как описано в предыдущей документации).  
* Функция get\_inbound\_ip(config\_str: str) \-\> Optional\[str\] (необходимо реализовать парсинг для извлечения IP-адреса сервера из config\_str).  
* Функция get\_outbound\_ip(config\_str: str, singbox\_path: str, timeout: float) \-\> Optional\[str\] (как описано в предыдущей документации).  
* Основная функция main(), которая будет:  
  * Парсить аргументы командной строки, включая путь к файлу с рабочими конфигурациями (переданному из url\_test.py), путь к sing-box и флаг verbose.  
  * Читать список рабочих конфигураций из переданного файла.  
  * Для каждой конфигурации из списка:  
    * Выполнять TCP-пинг (tcp\_ping\_test).  
    * Выполнять тест задержки TCP (tcp\_latency\_test).  
    * Определять входящий IP-адрес (get\_inbound\_ip).  
    * Определять исходящий IP-адрес (get\_outbound\_ip).  
    * Принимать решение о том, является ли конфигурация окончательно рабочей на основе результатов всех тестов.  
  * Записывать окончательный список рабочих конфигураций в выходной файл (путь к которому также может быть передан через аргумент командной строки).

### **3.3. Аргументы командной строки для advanced\_test.py**

Необходимо определить аргументы командной строки для advanced\_test.py:

* \--input\_file: Путь к временному JSON-файлу, содержащему список рабочих конфигураций от url\_test.py.  
* \--output\_file: Путь к файлу для записи окончательно проверенных рабочих конфигураций.  
* \--singbox\_path: Путь к исполняемому файлу sing-box.  
* \--verbose: Включить подробное логирование.  
* Возможно, параметры для целевого хоста и порта для TCP-пинга и теста задержки.

### **3.4. Логика обработки конфигураций в advanced\_test.py**

Функция main() в advanced\_test.py должна будет итерироваться по списку конфигураций, полученному из временного файла. Для каждой конфигурации необходимо выполнить все запланированные тесты. Решение о том, является ли конфигурация окончательно рабочей, должно приниматься на основе результатов всех этих тестов (например, все тесты должны пройти успешно без таймаутов).

## **4\. Преимущества и недостатки предложенной структуры**

**Преимущества:**

* **Скорость первоначальной фильтрации:** URL-тест является относительно быстрым, поэтому большинство нерабочих конфигураций будут отброшены на первом этапе, что сэкономит время на более ресурсоемкие тесты.  
* **Улучшенная организация кода:** Разделение на два файла делает код более модульным и легким для понимания и поддержки.  
* **Гибкость:** В будущем можно будет добавлять новые этапы тестирования, создавая дополнительные скрипты, которые будут запускаться последовательно.

**Недостатки:**

* **Дополнительное взаимодействие между файлами:** Требуется механизм для передачи данных между скриптами (например, через временный файл).  
* **Усложнение запуска:** Для запуска всего процесса теперь необходимо запустить первый скрипт, который затем запустит второй.

## **5\. Заключение**

Предложенная двухфайловая структура позволит более эффективно фильтровать прокси-конфигурации, сначала отсеивая нерабочие с помощью быстрого URL-теста, а затем проводя более глубокую проверку оставшихся. Разработчику необходимо реализовать функции для TCP-пинга, задержки TCP и определения IP-адресов во втором файле (advanced\_test.py), а также обеспечить передачу данных между файлами, как описано выше.